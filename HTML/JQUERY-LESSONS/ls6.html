<!DOCTYPE html>
<html>
<head>
	<title>lesson 6</title>
	<link rel="stylesheet" type="text/css" href="../../CSS/lessons.css">
</head>
<body>
<header id="navbar">
	<div class="container">
		<span id="brand-name">WebProgramming</span>
		<ul class="links">
			<a href="../index.html">
				<li>Home</li>
			</a>
			<a href="../about.html">
				<li>About</li>
			</a>
			<a href="../contactus.html">
				<li>ContactUs</li>
			</a>
		</ul>
	</div>
</header>
<div class="container">
<h1>Lesson 6</h1>
	<h2>Closures</h2>
<p>
Closures  are  created  whenever  a  variable  that  is  defined  outside  the  current  scope  is  accessed
from within some inner scope. Following example shows how the variable counter is visible
within the create, increment, and print functions, but not outside of them:
function create() { 
jQuery
21
var counter = 0;
return {
increment: function() {
counter++;
},
print: function() {
console.log(counter);  }
}
}
var c = create();
c.increment();
c.print();  // ==> 1
This pattern allows you to create objects with methods that operate on data that isn't visible
to the outside world. It should be noted that data hiding is the very basis of object-oriented
programming.
</p>
	<h2>Proxy   Pattern</h2>
<p>
A proxy is an object that can be used to control access to another object. It implements the
same  interface  as  this  other  object  and  passes  on  any  method  invocations  to  it.  This  other
object is often called the real subject. A proxy can be instantiated in place of this real subject
and  allow  it  to  be  accessed  remotely.  We  can  saves  jQuery's  setArray  method  in  a  closure
and overwrites it as follows:
(function() {
// log all calls to setArray
var proxied = jQuery.fn.setArray;
jQuery.fn.setArray = function() {
console.log(this, arguments);
return proxied.apply(this, arguments);
};
})();
The  above  wraps  its  code  in  a  function  to  hide  the  proxied  variable.  The  proxy  then  logs  all
calls  to  the  method  and  delegates  the  call  to  the  original  method.  Using  apply(this, 
jQuery
22
arguments)  guarantees  that  the  caller  won't  be  able  to  notice  the  difference  between  the
original and the proxied method.
</p>
</div>
<div class="links">
<a href="ls5.html">prev</a>
<a href="ls1.html">1</a>
<a href="ls2.html">2</a>
<a href="ls3.html">3</a>
<a href="ls4.html">4</a>
<a href="ls5.html">5</a>
<a href="ls6.html">6</a>
<a href="ls7.html">7</a>
<a href="ls8.html">8</a>
<a href="ls9.html">9</a>
<a href="ls10.html">10</a>
<a href="ls7.html">next</a>
</div>
<footer>
	<div class="container">
		Copyright &copy; 2021 WebProgramming
	<a href="#">
		<img width="2%" height="2%" src="../../IMAGES/facebook-brands.svg">
	</a>
	<a href="#">
		<img width="2%" height="2%" src="../../IMAGES/instagram-brands.svg">
	</a>
	<img src="">
	</div>
</footer>
</body>
</html>